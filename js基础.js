深度克隆
数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。
const a1 = [1, 2];
const a2 = a1;
a2[0] = 2;
a1 // [2, 2]
上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。
ES5 只能用变通方法来复制数组。
const a1 = [1, 2];
const a2 = a1.concat();
a2[0] = 2;
a1 // [1, 2]
上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。
扩展运算符提供了复制数组的简便写法。
const a1 = [1, 2];
// 写法一const a2 = [...a1];
// 写法二const [...a2] = a1;
上面的两种写法，a2都是a1的克隆。
用set去重之后。[...arr]就可以吧那个set形式数组变成正常数组。或者直接[...new Set(a)]
实现深度克隆

function deepClone(parent,child){
    var child = child || {},//有的话就等于child 没有就给一个空对象
     toStr = Object.prototype.toString, //为了判断对象还是数组
     arrStr = ['object Array'];
     for( var prop in parent){
        if(parent.hasOwnProperty(prop)){ //判断他不在原型链上的话
            if(typeof(parent[prop]) == "object"){ //不是原始值的话
           child[prop] = (toStr.call(paret[prop]) == arrStr)?[]:{};//是数组 返回空数组 是对象返回空对象
           deepClone(parent[prop],child[prop]);//递归调用 把当前的孩子节点继续递归调用
            }else{//判断是原始值
                child[prop] = parent[prop];
            }
        }
     }
}
json.parse(json.stringify[arr]);
this指向
function func(arg,arg2){
    console.log('hellow' + arg + arg2)
}
var obj = {

}
func.call(obj,' 1',' a')
func.apply(obj,[' 2',' a'])
call与apply都会在修改绑定的this时代入当前参数执行

func.bind(obj,' 3')
func.bind(obj,' 3')（‘ a’）
bind是硬绑定，会修改当前函数绑定的this，但不会执行，返回的是一个新的函数，这个新的函数this指向被修改，并且会将绑定是传入的参数（除第一个以外）都保留在新函数里占位，比如上面，原函数有两个形参，绑定的时候已经传入一个，那么新函数中的arg就默认是绑定时传入的值，执行新函数时，再传入一个参数后，该参数就被放置在除第一个参数位置以后的参数位置上，例子中为arg2，这个原理源于柯理化
实现bind

Function.prototype.bind = function(context){
  var args = Array.prototype.slice.call(arguments, 1),
  self = this;
  return function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply(context,finalArgs);
  };
};

数组方法
栈和队列
1.队列先进先出，栈先进后出。
2.对插入和删除操作的"限定"：
栈是限定只能在表的一端进行插入和删除操作的线性表。
队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。
3、操作方法：
队列操作的方法 shift unshift
栈操作 pop push
eg:
var list = [0,1,2]
shift():
删除数组的第一个元素,返回删除的值。这里是0
unshift(3,4):
把参数加载数组的前面，返回数组的长度。现在list中是3,4,0,1,2，返回值为5
pop():
删除数组的最后一个元素，返回删除的值。这里是2
push(3):
将参数加载到数组的最后，返回数组的长度，现在List中时：0,1,2,3，返回值为4
concat(3,4):
把两个数组拼接起来,返回一个数组副本，值为0,1,2,3,4
splice(index,howmany,item1,.....,itemX):
howmany删除项目数量，item为添加的项目
sort():
是按照字符编码的顺序进行排序,中间加函数可实现乱序 里面传一个函数 a b a>b 看返回值 返回正值就调换顺序 返回负值不掉换
reverse():
方法用于颠倒数组中元素的顺序。
join():
方法用于把数组中的所有元素放入一个字符串。
toString():
方法可把数组转换为字符串，并返回结果。加radix，也可以转化成十进制
字符串方法
charCodeAt(index):
方法返回一个整数，代表指定位置字符的Unicode编码。
fromCharCode(code1,code2...):
方法从一些Unicode字符串中返回一个字符串。
charAt(index):
方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。
slice(start,end):
方法返回字符串的片段。 算头不算尾。
substring(start,end):
方法用于提取字符串中介于两个指定下标之间的字符。算头不算尾。
substr(start,length):
方法返回一个从指定位置开始的指定长度的子字符串。
indexOf(substr,startIndex):
方法放回String对象内第一次出现子字符串位置。没有找到子字符串，则返回-1。
split(separator,limit):
将一个字符串分割为子字符串，然后将结果作为字符串数组返回。limit该值用来限制返回数组中的元素个数。
concat(string1,string2...):
方法返回字符串值，该值包含了两个或多个提供的字符串的连接。
search():
方法返回与正则表达式查找内容匹配的第一个字符串的位置。
toLowerCase()/toUpperCase():
改变字符串中的字母大小写

字符串replace的话，正常来说只是第一个改，想要都改的话，需要'11 2233'.replace(/3/g,5)    加上 / /g，或者replaceAll
由于字符串是原始值，字符串修改不了，想要修改的话，只能用正则或者变成数组，修改完数组在改回去
function replaceSpace(str)
{
    var arr = str.split('');
    for(var i = 0;i<arr.length;i++){
        if(arr[i]===" "){
            arr[i] = '%20'
        }
    }
    return arr.join('')
}
原型、原型链、作用域、立即执行函数、闭包、继承、预编译
1.原型的定义：
原型是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先。
通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。
有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，
这样的原型上还有原型的结构就构成了原型链。

/注意:
1.绝大部分的对象最终都会继承自Object.prototype这个对象。
并不是所有的对象都有原型，undefined null也都没有原型。

当我们通过的一个对象改变了原型上引用值类型的属性的话，那么所有对象的这个属性的值都会随之更改.
但是对象并不能删除原型上的属性。
谁调用这个方法，这个方法中的this就指向这个调用它的对象。/

2.原型链

有了原型，原型还是一个对象，那么这个名为原型的对象自然还有自己的原型，这样的原型上还有原型的结构就构成了原型链。
当我们查找son上的属性的时候，如果son自身有属性，那么就打印出来，如果没有，就向上查找原型father，如果father上面还有这个属性，那么继续向上查找grandfoo，如果有就输出，如果没有就返回undefined。
这种链式的查询结构就叫做原型链。

3.作用域:
es5的作用域有全局作用域和函数作用域，es6中添加了块级作用域
函数作用域：
定义：变量（变量作用域又称为上下文）和函数生效（能被访问）的区域
JavaScript的函数是可以产生作用域的。

/注意：
如果在函数作用域里面声明变量没有用var的话，那么就声明了一个全局变量。
同时，两个不同作用域（除了全局作用域）之间是不能互相访问的/

4.作用域链
由于函数可以互相嵌套，作用域之间自然也会产生互相嵌套的关系，这个时候就会产生作用域链。
当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境的有权访问的变量和函数的有序访问
作用域第一个对象始终是当前执行代码所在环境变量对象


5.立即执行函数
是解闭包的一个重要方法。但是注意闭包是没有办法解除的，
我们只能通过另一个新闭包来消除上一个闭包的影响。

定义：立即执行函数不需要被定义，直接执行，执行完毕之后直接释放。

6.闭包
闭包就是能够读取其他函数内部变量的函数.
不同作用域之间不能够互相访问，但是我们如果在一个函数内部再定义一个函数，并且这个内部函数与外部函数的变量有关联，
那么我们就可以通过返回这个内部的函数，然后来访问外部函数里面的变量。
这个函数返回了一个依赖于这个函数的新函数，也就是说这个没有被销毁的新函数的作用域链中还存在着
对原本函数的作用域的引用，就导致我们原本的函数的上下文不会被销毁，
我们称返回的这个新函数是原本函数的闭包函数。

闭包的缺点：

1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，
所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
解决方法是，在退出函数之前，将不使用的局部变量全部删除。

闭包作用：

闭包主要是保护局部变量不被回收，如节流函数，防抖函数等都需要通过闭包方法实现。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

7.继承
几种方式:
1.传统方式使用原型链继承 浪费继承了太多无用属性
2.构造函数
用call和apply 改变this指向
3.共享原型
就是父子构造函数一样
缺点：无法改变子类原型 要改只能改一个
4.圣杯模式
/原理： 函数的原型等于父级的原型 这样改变一个就不会改变父级属性
写一个新的中间的构造函数 把p的原型给f的原型 通过new一个f让他等于c的原型
共享一下f和p的原型 通过f构造出c的原型 共享原型有一个问题 构造出的对象可以改变原型上的方法
p=f C = new F/

var inherit = (function(){
var F = function(){}
return function(C,P){
F.prototype = P.prototype;
C.prototype = new F();
C.prototype.constructor = C;
C.prototype.uber = P.prototype;//最后再补充一下 构造完这些 我是由谁来的 就是P.prototype
}
}());

7(+).对象如何查看构造自身的构造函数
在prototype里面，有一个隐式的属性叫做constructor，这个属性记录的就是对象的构造器，里面存的就是构造函数。
console.log(oPerson.constructor); // Person();
深层克隆
function deepCopy(src,tar){
var tar= tar|| {} ;
for (var prop in src){
if (typeof (src[prop]) == 'object'){
tar[prop] = (src[prop].constructor === Array ) ? [] : {};
deepCopy(src[prop],tar[prop]);
}else {
tar[prop] = src[prop];
}
}

return tar;
}


8.预编译

预编译前奏
1.imply global 暗示全局变量
.如果任何变量未经声明就赋值使用，此变量就会为全局对象window所有，并且成为window对象的一个属性。
2.一切声明的全局变量，都是window的属性。
//区别在于：经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除

预编译时this指向window。
1.创建AO对象。
首先第一步，创建一个AO对象（执行器上下文）。var AO = {};

2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。

3.将实参值和形参值相统一。这里因为属性名都已经存在了，所以直接赋值就可以了。

4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。

/注意：
函数在执行的前一刻会产生一个上下文，这个上下文就是Activeaction Object对象，简称AO对象。AO = {}
这个对象是空的，但是里面有一些我们看不到的却存在的隐式属性，比如this: window属性和arguments: [];属性/
这个对象用来存放一些属性和方法，这些属性和方法就按照前面的四步来产生。
js加载时间线
1、创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。
2、遇到link外部css，创建线程加载，并继续解析文档。
3、遇到script外部js，并且没有设置async、defer，浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。
4、遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。 对于async属性的脚本，脚本加载完成后立即执行。
（异步禁止使用document.write()）,而defer是等DOMTree解析完成后才执行
5、遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。
6、当文档解析完成，document.readyState = ‘interactive’。
7、文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,
但同样禁止使用document.write()）;
8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，
转化为事件驱动阶段。
9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window
对象触发load事件。
10、从此，以异步响应方式处理用户输入、网络事件等
性能优化
前端优化的途径有很多，大致可以分为两类：页面级优化和代码级优化。

页面级优化有减少HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等等。

代码级优化有Js种DOM操作优化、Css选择符优化、图片优化以及HTML结构优化等等。

1.页面级优化
2.代码级优化


//页面级优化:
//<----1.减少HTTP请求数 (最重要最有效)----->
一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个漫长而复杂的过程。
由于浏览器进行并发请求的请求数都是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，
会给用户造成网站速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条一直在加载。

// 减少HTTP请求数的途径主要有一下几个：

/（1）从设计实现层面简化页面

如果我么你的页面和百度搜索的页面一眼简单，那么也就不需要什么优化操作了。因此保持页面简洁、减少资源的使用是最直接的。

/（2）合理设置HTTP缓存

缓存的力量是强大的，恰当的设置缓存可以大大减少HTTP请求
怎样才算是合理的设置？原则很简单：能缓存越多越久越好。
例如：很少变化的图片资源就可以直接通过HTTP Header中的Expires设置一个很长的过期头；
变化不频繁而又可能会变的资源可以使用Last-Modified来做请求验证。尽可能的让资源能够在缓存中待的更久。

/（3）资源合并与压缩

如果可以的话，尽可能的将外部脚本、样式进行合并，尽可能地合并为一个。另外，CSS、Js、Image都可以用相应的工具
进行压缩，压缩后往往能节省不少空间。或者使用Webpack等前端工程化工具来进行代码的压缩和去重。

/（4）CSS Sprites 雪碧图

雪碧图又叫做精灵图，我们可以把网站中需要用到的一些icon，全部放到一个图片资源中，然后通过改变位置来
获取需要的图片，这样合并CSS图片，就可以大幅度减少HTTP请求数了。

/ (5). Inline Images
　　使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。
如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。

/ (6). Lazy Load Images（自己对这一块的内容还是不了解） 懒加载
　　 这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。
对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，
假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。
有啊首页 曾经的做法是在加载的时候把第一屏之后的图片地址缓存在 Textarea标签中，待用户往下滚屏的时候才 “惰性” 加载。

/（6）瀑布流

其实懒加载并不能减少HTTP请求数，他只是可以减少页面刚加载的时候的HTTP请求数，总数是不变的。
对于图片而言，在页面刚加载的时候可能只加载第一屏的图片，随着用户的滚动才会继续加载后面的图片资源，
这种瀑布流的加载方式就可以有效提高性能。

// 2.将外部脚本放在底部
前文有谈到，浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，
例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。
如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，
在 这里有比较详细的介绍 (这里是译文和 更详细的例子 )，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。

// 3.并发执行inline脚本
使用 script元素的defer 属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，
在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。

// 4.懒加载
只需要在需要资源的时候才加载资源，不需要的时候就不加载资源。

// 5. 将 CSS放在 HEAD中
　　 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，
用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。

/ Js 与 css 懒加载
把js放到整个页面的底部， 另一个方法是在script 标签上加一个 defer属性 保证让浏览器把脚本下载出来后，
然后等到页面渲染完毕再执行。（参考权威指南 js时间线）
Css文件用link标签加载 是阻塞状态的，我们可以使用loadCss 小工具库来进行异步css文件加载，但是有一个问题是
，全部异步加载css ，页面最开始呈现出的只是单纯的html ,不是很好看 所以我们要选定一个关键的css文件，
用critical 工具来自动提取压缩关键的css. （百度自行查看使用方法）


// 8.减少不必要的HTTP跳转

对于以目录形式访问的HTTP链接，很多人都会忽略链接最后是否带’/’，加入你的服务器对此区别对待的话，那么你也需要注意了，
这其中很可能隐藏了301跳转，增加了多余请求。

// 9.避免重复的资源请求

这种情况主要是由于在模块化开发时，我们的不同模块之间可能有相同的部分，导致资源的重复请求。

二、代码级优化

//1.DOM

DOM操作应该是脚本中最耗性能的一类操作
/（1）HTMLCollection（HTML收集器，返回的是一个数组的内容信息）
因为是这个集合并不是一个静态的集合，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个 查询从而更新查询结果。
所谓的“访问集合”包括读取集合的length属性、访问集合中的元素。

/（2）Reflow&Repaint
减少页面的重绘和重排。

//2.慎用with
with会改变作用域链，有可能导致我们的作用域链变长，导致查询性能下降。

//3.避免使用eval和Function
每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作
—— 通常比简单的函数调用慢 100倍以上。

// 4.减少作用域链查找
如果在循环中需要访问非本作用域下的变量的时候，请遍历之前用局部变量缓存的变量，并在遍历结束之后重写这个缓存变量

//5.数据访问

js中对直接量和局部变量的访问时最快的，对对象属性以及数组的访问需要更大的开销，当出现下面的情况的时候，建议将数据放入局部变量：

/（1）对任何对象属性的访问超过1次

/（2）对任何数组成员的访问次数超过1次

另外，要尽可能的减少对对象以及数组的深度查找。

//6.字符串拼接

字符串的拼接尽可能少的使用“+”，这种方式的效率是十分低下的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接的结果赋
值给新变量。

建议使用的是先转化为数组，然后通过数组的join方法来连接成字符串。不过由于数组也有一定的开销，因此就需要权衡一下，当拼接的字符串比
较少的时候，可以考虑用“+”的方式，比较多的时候就需要考虑用数组的join方法了。